{
	debug
	local_certs
	skip_install_trust
	auto_https disable_redirects
	admin :{$GB_DD_LOCAL_ADMIN_PORT:2019}
	storage file_system {$GB_DD_CADDY_REMOTE_DIR}
}

# Configures the docker socket for local and internal access
# TODO: put more secure boundries around this - Figure out authentication
# Call this endpoint from pod:
#   * docker -H http://goblet-dind:2375 info
http://{$GB_DD_CADDY_HOST:localhost}:{$GB_DD_DOCKER_PORT:2375}, http://{$GB_DD_DEPLOYMENT:goblet-dind}:{$GB_DD_DOCKER_PORT:2375}, http://{$GB_DD_DOCKER_HOST:0.0.0.0}:{$GB_DD_DOCKER_PORT:2375} {
	log
	reverse_proxy unix///var/run/docker.sock
	# bind unix///var/run/docker.sock
}

# Grabs the last subdomain of the host, and uses it as the port in the reverse_proxy
# This allows dynamic routing to exposed ports based on the Host headers last subdomain
# Call this endpoint from pod:
#   * curl --header "Host: <port>.<user-id>.conductor.local.gobletqa.app" http://goblet-dind:2121
# 	* curl --header "Host: 34375.2098242360.conductor.local.gobletqa.app" http://goblet-dind:2121
http://*.*.{$GB_CD_SUB_DOMAIN}.{$GB_CD_HOST}:{$GB_DD_API_PROXY_PORT} {
	reverse_proxy {$GB_DD_PROXY_DOMAIN:localhost}:{labels.5}

	handle_errors {
		respond "\{\"error\":\"{err.status_code} {err.status_text}\"\}"
	}
}

# We don't have access to override the host header, so instead we pass the port as a query param
# This follows a non-standard process of passing the port as a param
# It passes just the value, and not a keg=value pair as is standard
# Doing it this way allows us to use the query directly as the port without any parsing
# 

http://{$GB_DD_DEPLOYMENT}:{$GB_DD_VNC_PROXY_PORT} {
	@websockets {
		header Connection *Upgrade*
		header Upgrade websocket
	}

	reverse_proxy @websockets {$GB_DD_PROXY_DOMAIN:localhost}:{query}
}

http://{$GB_DD_DEPLOYMENT}:{$GB_DD_WS_PROXY_PORT} {
	@websockets {
		header Connection *Upgrade*
		header Upgrade websocket
	}

	reverse_proxy @websockets {$GB_DD_PROXY_DOMAIN:localhost}:{query}
}
